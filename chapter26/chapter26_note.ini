P631 类产生多个实例对象：
     类对象提供默认行为，是实例对象的工厂。实例对象是程序处理的实际对象，各自都有独立的命名空间，但是继承创建该实例的类中的变量名。类来自于语句，而实例来自于调用。每次调用一个类，就会得到这个类的新的实例。
P632 类对象提供默认行为：
     class语句创建类对象并将其赋值给变量名。class语句内的赋值语句会创建类的属性。类属性提供对象的状态和行为。
P632 实例对象是具体的元素：
     像函数那样调用类对象会创建新的实例对象。每个实例对象继承类的属性并获得了自己的命名空间。在方法内对self属性做赋值运算会产生每个实例自己的属性。
P635 类通过继承进行定制：
     超类列在了类开头的括号中。类从其超类中继承属性。实例会继承所有可读取类的属性。每个object.attribute都会开启新的独立搜索。逻辑的修改时通过创建子类，而不是修改超类。
p638 类可以截获python运算符：
     运算符重载就是让用类写成的对象，可截获并响应用在内置类型上的运算：加法，切片，打印和点号运算等。
     以双下划线命令的方法(__X__)是特殊钩子。python运算符重载的实现是提供特殊命名的方法来拦截运算。python语言替每种运算和特殊命名的方法之间，定义了固定不变的映射关系。
     当实例出现在内置运算时，这类方法会自动调用。例如，如果示例对象继承了__add__方法，当对象出现在+表达式内时，该方法就会调用。该方法的返回值会变成相应表达式的结果。
     类可覆盖多数内置类型运算。有几十种特殊运算符重载的方法的名称，几乎可截获并实现内置类型的所有运算。它不仅包含了表达式，而且像打印和对象建立这类基础运算也包括在内。
     运算符重载方法没有默认值，而且也不需要。如果类没有定义或继承运算符重载方法，就是说相应的运算在类实例中并不支持。例如，如果没有__add__，+表达式就会引发异常。
     运算符可让类与python的对象模型相集成。重载类型运算符时，以类实现的用户定义对象的行为就会像内置对象一样，因此，提供了一致性，以及与预期接口的兼容性。
P639 当新的实例构造时，会调用__init__。当实例出现在+表达式中时，则会调用__add__。当打印一个对象时，运行__str__。
P646 类和模块之间有什么关系？
     类总位于模块中；类是模块对象的属性。类和模块都是命名空间，但类对应于语句（而不是整个文件），而且支持多个实例、继承以及运算符重载这些OOP概念。总之，模块就像是单个的实例类，没有继承，而且模块对应于整个文件的代码。
P646 实例和类是如何创建的？
     类是通过运行class语句创建的；实例是像函数那样调用类来创建的。
P646 类属性是在哪里创建的？是怎么样创建的？
     类属性的创建时通过把属性赋值给类对象实现的。类属性通常是由class语句中的顶层赋值语句而产生的：每个在class语句代码区中赋值的变量名，会变成类对象的属性（从技术角度来讲，class语句的作用域会变成类对象的属性的命名空间）。不过，也可以于任何引用类对象的地方（在class语句外）对其属性赋值，从而也可以创建类属性。
P646 实例属性是在哪里创建的？是怎么样创建的？
     实例属性是通过对实例对象赋值属性来创建的。实例属性一般是在class语句中的类方法函数中对self参数（永远是隐含实例）赋值属性而创建的。不过，你也可以在任何地方引用实例通过赋值语句来创建属性，即使在class语句外。一般来说，所有实例属性都是在__init__构造函数中初始化的。这样的话，之后的调用都可假设属性已经存在。
P646 python类中的self有什么意义？
     self通常是给类方法函数的第一个（最左侧）参数的名称；python自动填入实例对象（也就是方法调用的隐含的主体）。这个参数不必叫self，其位置才是重点（C++或Java程序员更喜欢把它称作this，因为在这些语言中，该名称反应的是相同的概念。不过，在python中，这个参数总是需要明确的）。
P646 python类中如何编写运算符重载？
     python类中的运算符重载是用特定名称的方法写成的。这些方法的开头和结尾都是双下划线，通过这种方法使其变得独特。这些不是内置或保留字。当实例出现在相应的运算符中时，python就会自动执行它们。python为这些运算和特殊方法的名称定义了对应关系。
P646 python OOP程序代码中最重要的两个概念是什么？
     方法函数中的特殊self参数和__init__构造函数是python OOP的两个基石。
