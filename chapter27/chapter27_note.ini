P666 python的OOP机制中重要的概念：
     实例创建——填充实例属性。
     行为方法——在类方法中封装逻辑。
     运算符重载——为打印这样的内置操作提供行为。
     定制行为——重新定义子类中的方法以使其特殊化。
     定制构造函数——为超类步骤添加初始化逻辑。
     这些概念中的大多数基于3个简单的思路：在对象树中继承查找属性，方法中特殊的self参数以及运算符重载对方法的自动派发。
P670 内置的instance.__class__属性提供了一个从实例到创建它的类的链接。类反过来有一个__name__，还有一个__basese__序列，提供了超类的访问。我们使用这些来打印创建一个实例的类的名字，而不是通过硬编码来做到。
     内置的object.__dict__属性提供了一个字典，带有一个一个键/值对，以便每个属性都附加到一个命名空间对象（包括模块，类和实例）。由于它是字典，因此我们可以获取键的列表，按照键来索引，迭代其键等等，从而广泛地处理所有的属性。我们使用这些来打印出任何实例的每个属性，而不是在定制显示中硬编码。

person.py
#coding=utf-8

class Person:
    def __init__(self,name,job=None,pay=0):
        self.name = name
        self.job = job
        self.pay = pay
    def __str__(self):
        return '[Person: %s,%s]'%(self.name,self.pay)
        
if __name__=='__main__':
    bob=Person("bob",job="SA",pay=100)
    print(bob.pay)
    print(getattr(bob, "pay"))
    print(bob)
    print(Person.__dict__)
    print(Person.__class__)
    print(Person.__name__)
    print(Person.__base__)
    print(bob.__dict__)
    print(bob.__class__)

100
100
[Person: bob,100]
{'__init__': <function Person.__init__ at 0x7fce9391b268>, '__weakref__': <attribute '__weakref__' of 'Person' objects>, '__dict__': <attribute '__dict__' of 'Person' objects>, '__str__': <function Person.__str__ at 0x7fce9391b620>, '__doc__': None, '__module__': '__main__'}
<class 'type'>
Person
<class 'object'>
{'job': 'SA', 'name': 'bob', 'pay': 100}
<class '__main__.Person'>

P674 为了减少方法名称冲突的机会，对于不想做其他用途的方法添加一个单个下划线的前缀。一个更好但不常用的方法是，只是在方法名前使用两个下划线符号，python自动扩展这样的名称，以包含类的名称，从而使它们变得真正唯一，这一功能叫做伪私有类属性。
P676 对象持久化通过3个标准的库模块来实现。
	 pickle：任意python对象和字节串之间的序列化。
     dbm：实现一个可通过键访问的文件系统，以存储字符串。
     shelve：使用另两个模块按照键把python对象存储到一个文件中。
	 尽管使用pickle本身把对象存储为简单的普通文件并随后载入它们是很容易的，但shelve模块提供了一个额外的层结构，允许按照键来存储pickle处理后的对象。shelve使用pickle把一个对象转换为其pickle化的字符串，并将其存储在一个dbm文件中的键之下；随后载入的时候，shelve通过键获取pickle化的字符串，并用pickle在内存中重新创建最初的对象。一个shelve的pickle对象看上去就像是字典——我们通过键索引访问，指定键来存储，并且使用len，in和dict.keys这样的字典工具来获取信息。shelve自动把字典映射到存储在文件中的对象。
     对于脚本来说，一个shelve和一个常规的字典之间的唯一的编码区别就是，一开始必须打开shelve并且在修改之后必须关闭它。
P684 为什么把处理放入方法中而不是在类之外硬编码如此重要？
     当处理放入方法中很重要，这样一来，未来只有一个副本需要修改，并且方法可以在任何实例之上运行。这就是python封装的概念，把逻辑封装到接口背后，更好地支持未来的代码维护。如果没有这么做，就会产生代码冗余性，将来代码修改的时候工作就会加倍。
P684 为什么通过子类而不是复制并修改最初的代码来定制会更好？
     用子类定制可以减少开发工作。在OOP中，我们通过定制已经做过的事情来编码，而不是复制和修改已有的代码。这是OOP中真正的“大思路”，因为我们可以通过编写新的子类来很容易地扩展以前的工作，我们可以利用已经做过的事情。这比每次从头开始编写要好很多，也好过引入多个冗余的代码副本，它们未来可能全部都必须更新。
P684 为什么回调一个超类的方法来运行默认操作而不是在子类中复制和修改其代码要更好？
     不管是什么样的情况，复制和修改代码会使未来的潜在工作翻倍。如果一个子类需要执行超类方法中编写的默认行为，通过超类的名称回去调用最初的方法而不是复制其代码，这种做法要好很多。这对于超类的构造函数也有效。再次强调，复制代码会产生冗余性，当代码改进的时候这是一个主要的问题。
