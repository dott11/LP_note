P894 Python 3.0中最引入注目的修改之一，就是字符串对象类型的变化。简而言之，Python 2.X的str和unicode类型已经融入了Python 3.0的str和bytes类型，并且增加了一种新的可变的类型bytearray。
P896 Unicode文本通常叫做“宽字符”字符串，因为每个字符可能表示为多个字节。Unicode通常用在国际化的程序中，以表示欧洲和亚洲的字符集，它们往往拥有比8位字节所能表示的更多的字符。
     要在计算机内存中存储如此丰富的文本，我们要确保字符与原始字节之间可以使用一种编码相互转换，而编码就是把一个Unicode字符转换为字节序列以及从一个字节序列提取字符串的规则。更程序化地说，字节和字符串之间的来回转换由两个术语定义：
     编码是根据一个想要的编码名称，把一个字符串翻译为其原始字节形式。
     解码是根据其编码名称，把一个原始字节串翻译为字符串形式的过程。
     也就是说，我们从字符串编码为原始字节，并且从原始字节解码为字符串。
P897 Python 2.X有一种通用的字符串类型来表示二进制数据和像ASCII这样的8位文本，还有一种特定的类型用来表示多字节Unicode文本：
     str表示8位文本和二进制数据。
     unicode用来表示宽字符Unicode文本。
     Python 3.X带有3种字符串对象类型——一种用于文本数据，两种用于二进制数据：
     str表示Unicode文本（8位的和更宽的）。
     bytes表示二进制数据。
     bytearray，是一种可变的bytes类型。
P898 Python 3.0的str类型定义为一个不可改变的字符序列（不一定是字节），这可能是像ASCII这样的每个字符一个字节的常规文本，或者是像UTF-8 Unicode这样可能包含多字节字符的字符集文本。
     在Python 3.0中，bytes类型定义为一个8位整数的不可变序列，表示绝对的字节值。
     Python的开发者也在Python 3.0中添加了一个bytearray类型，bytearray是bytes类型的一个变体，它是可变的并且支持原处修改。
P900 更正式地说，在Python 3.0中，所有当前字符串常量形式，'xxx'、"xxx"和三引号字符串块，都产生一个str；在它们任何一种前面添加一个b或B，则会创建一个bytes。这个新的b'...'字节常量类似于用来抑制反斜杠转义的r'...' raw字符串。
P902 str.encode()和bytes(S, encoding)把一个字符串转换为其raw bytes形式，并且在此过程中根据一个str创建一个bytes。
     bytes.decode()和str(B, encoding)把raw bytes转换为其字符串形式，并且在此过程中根据一个bytes创建一个str。
P910 对于在脚本文件中编码的字
符串，Python默认地使用UTF-8编码，但是，它允许我们通过包含一个注释来指明想要的编码，从而将默认值修改为支持任意的字符集。这个注释必须拥有如下的形式，并且在Python 2.6或Python 3.0中必须作为脚本的第一行或第二行出现：
     # -*- coding: latin-1 -*-
     当出现这种形式的注释时，Python将自然按照给定的编码来识别表示的字符串。
P911 正如前面提到的，Python 3.0 bytes对象是较小整数的一个序列，其中每个整数都在0到255之间，并且在显示的时候恰好打印为ASCII字符。它支持序列操作以及str对象（在Python 2.X中是str类型）上可用的大多数同样方法。然而，bytes不支持格式化方法或%格式化表达式，并且，不能不经过显式转换就将bytes和str类型对象混合和匹配——我们通常使用针对文本数据使用所有的str类型对象和文本文件，并且针对二进制数据使用所有的bytes对象和二进制文件。
P915 Python 3.0还有第三个字符串类型bytearray，这是范围在0到255之间的整数的一个可变的序列，其本质是bytes的可变的变体。同样，它支持和bytes同样的字符串方法和序列操作，并且与列表支持同样多的可变的原处修改操作。
P918 Python 3.0的字符串模型对本书前面所介绍的文件处理基础知识的影响，关键是用哪种模式打开一个文件，它决定了在脚本中将要使用哪种对象类型表示文件的内容。文本模式意味着str对象，二进制模式意味着bytes对象：
     文本模式文件根据Unicode编码来解释文件内容，要么是平台的默认编码，要么是我们传递进的编码名。通过传递一个编码名来打开文件，我们可以强行进行Unicode文件的各种类型的转换。文本模型的文件也执行通用的行末转换：默认地，所有的行末形式映射为脚本中的一个单个的'\n'字符，而不管在什么平台上运行。正如前面所描述的，文本文件也负责阅读和写入在某些Unicode编码方案中存储文件开始处的字节顺序标记（Byte Order Mark，BOM）。
     二进制模式文件不会返回原始的文件内容，而是作为表示字节值的整数的一个序列，没有编码或解码，也没有行末转换。
P922 可以根据目标编码名称把一个字符串转换为raw bytes:
#coding=utf-8

S = 'A\xc4B\xe8C'
print(S)
L=S.encode(encoding='utf_8')
print(L)
print(len(L))
U=S.encode(encoding='latin-1')
print(U)
print(len(U))

AÄBèC
b'A\xc3\x84B\xc3\xa8C'
7
b'A\xc4B\xe8C'
5
P935 Python 3.0中字符串对象类型的名称和角色是什么？
     Python 3.0有3种字符串类型：str（用于Unicode文本，包括ASCII）、bytes（用于带有绝对字节值的二进制数据）和bytearray（bytes的一种可变的形式）。str类型通常表示存储在文本文件中的内容，其他的两种形式通常表示存储在二进制文件中的内容。
P936 Python 2.6中字符串对象类型的名称和角色是什么？
     Python 2.6有两种主要的字符串类型：str（用于8位文本和二进制数据）以及unicode（用于宽字符文本）。str类型用于文本和二进制文件内容，unicode用于通常比8位更复杂的文本文件内容。Python 2.6（但不包括更早的版本）也有Python 3.0的bytearray类型，但它主要是一种向后兼容，而且并没有表现出Python 3.0中所表现出来的鲜明的文本/二进制区别。
P936 Python 2.6和Python 3.0中的字符串类型是如何对应的？
     从Python 2.6到Python 3.0的字符串类型对应并不是直接的，因为Python 2.6的str等同于Python 3.0中的str和bytes，并且Python 3.0中的str等同于Python 2.6中的str和unicode。Python 3.0中bytearray的可变性是唯一的。
P936 在Python 3.0中，如何把非ASCII Unicode字符编写到字符串中？
     非ASCII Unicode字符可以以十六进制转移（\xNN）和Unicode转义（\uNNNN,\UNNNNNNNN）编写到一个字符串中。在某些键盘上，一些非ASCII字符——例如，某些Latin-1字符，也可以直接录入。
P936 为什么把ASCII文本看做是一种Unicode文本？
     ASCII文本看作是一种Unicode文本，因为其7位范围值只是大多数Unicode编码的一个子集。例如，有效的ASCII文本也是有效的Latin-1文本（Latin-1只是把一个8位字节中其余可能的值分配给额外的字符），并且是有效的UTF-8文本（UTF-8为表示更多的字符定义了一个变量-字节方案，但是ASCII字符仍然用同样的代码表示，即单个的字节）。
