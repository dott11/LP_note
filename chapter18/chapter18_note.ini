P444 传递参数：
     1.参数的传递时通过自动将对象赋值给本地变量名实现的。
     2.在函数内部的参数名的赋值不会影响调用者。
     3.改变函数的可变对象函数的值也许会对调用者有影响。
     4.不可变参数“通过值”进行传递。
     5.可变对象是通过“指针”进行传递。
 
P449 特定的参数匹配模型：
     语法                   位置                    解释
     func(value)            调用者                  常规参数：通过位置进行匹配
     func(name=value)       调用者                  关键字参数：通过变量名匹配
     func(*sequence)        调用者                  以name传递所有的对象，并作为独立的基于位置的参数
     func(**dict)           调用者                  以name成对的传递所有的关键字/值，并作为独立的关键字参数
     def func(name)         函数                    常规参数：通过位置或变量名进行匹配
     def func(name=value)   函数                    默认参数值，如果没有在调用中传递的话
     def func(*name)        函数                    匹配并收集（在元组中）所有包含位置的参数
     def func(**name)       函数                    匹配并收集（在字典中）所有包含位置的参数
     def func(*arg,name)    函数                    参数必须在调用中按照关键字传递
     def func(*,name=value)                        （Python 3.0）

P452 有关顺序的法则：
     1.在函数调用中，参数必须以此顺序出现：任何位置参数（value），后面跟着任何关键字参数（name=value）和*sequence形式的组合，后面跟着**dict形式。
     2.在函数头部，函数必须以此顺序出现：任何一般参数（name），紧跟着任何默认参数（name=value），如果有的话，后面是*name（或者在Python3.0中是*）的形式，后面跟着任何name或name=value keyword-only参数（在Python3.0中），后面跟着**name形式。

P459 Python3.0 keyword-only参数：
     keyword-only参数——即必须只按照关键字传递并且不会由一个位置参数来填充的参数。如果想要一个函数既处理任意多个参数，也接受可能的配置选项的话，这是很有用的。

P466 Python2.6导入Python3.0的print函数：
     from __future__ import print_function

P471 举出三种以上函数和调用者能够交流结果的方法：
     函数可以用return语句、修改出入的可变参数以及通过设置全局变量来返回其结果。函数也可以和系统组件进行通信，例如文件和套接字。
