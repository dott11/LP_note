P361 已打开的文件对象有一个方法名为readline，可以一次从一个文件中读取一行文本，每次调用readline方法时，就会前进到下一列。到达文件末尾时，就会返回空字符串。
     文件也有一个方法，名为__next__，差不多有相同的效果；每次调用时，就会返回文件中的下一行。到达文件末尾时，__next__会引发内置的StopIteration异常，而不是空字符串。
     这个接口就是Python中所谓的迭代协议：有__next__方法的对象会前进到下一个结果，而在一系列结果的末尾时，则会引发StopIteration。在Python中，任何这类对象都认为是可迭代的。任何这类对象也能以for循环或其他迭代工具遍历，因为所有迭代工具内部工作起来都是在每次迭代中调用__next__，并且捕捉StopIteration异常来确定何时离开。

P363 Python3.0还提供了一个内置函数next，它会自动调用一个对象的__next__方法。给定一个可迭代对象X，调用next(X)等同于X.__next__()。

P368 列表解析写起来更加精简，并且由于构建结果列表的这种代码样式在Python代码中十分常见，因此可以将它们用于多种环境。此外，列表解析比手动的for循环语句运行的更快，因为它们的迭代在解释器内部是以C语言的速度执行的，而不是手动Python代码执行的，特别是对于较大的数据集合，这是使用列表解析的一个主要的性能优点。

P375 Python3.0比如2.X更强调迭代。除了与文件和字典这样的内置类型相关的迭代，字典方法keys，values和items都在Python3.0中返回可迭代对象，就像内置函数range，map，zip和filter所做的那样。这些工具在Python3.0中都根据请求产生结果，而不是像它们在Python2.6中那样构建结果列表。

P376 在Python3.0中，range函数返回一个迭代器，该迭代器根据需要产生范围中的数字，而不是在内存中构建一个结果列表。这取代了较早的Python2.X xrange。如果需要一个范围列表的话，你需要使用list(range(...))来强制一个真正的范围列表。

P377 和range类似，map，zip以及filter内置函数在Python3.0中也转变为迭代器以节约内存空间，而不再在内存中一次性生成一个结果列表。

P378 range支持在其结果上的多个迭代器，这些迭代器会记住它们各自的位置。相反，zip，map，filter不支持相同结果上的多个活跃迭代器。

P381 for循环和迭代器之间有什么关系？
     for循环会使用迭代协议来遍历迭代的对象中的每一个项。for循环会在每次迭代中调用该对象的__next__方法（由next内置函数运行），而且会捕捉StopIteration异常，从而决定何时停止循环。支持这种模式的任何对象，都可以用于for循环以及其他迭代环境中。

     for循环和列表解析直接有什么关系？
     两者都是迭代工具。列表解析是执行常见for循环任务的简明并且高效的方法：对可迭代对象内所有元素应用一个表达式，并收集其结果。你可以把列表解析转换成for循环，而列表解析成for循环，而列表解析表达式的一部分的语法看起来就像是for循环的首行。

     举出Python中的4种迭代环境。
     Python中的迭代环境包括for循环，列表解析，map内置函数，in成员关系检测表达式以及内置函数sorted，sum，any和all。这个分类也包括了内置函数list和tuple，字符串join方法以及序列复制运算。所有这些都使用了迭代协议（next方法）来一次一个元素逐个遍历可迭代对象。

     如今从一个文本文件逐行读取行的最好的方法是什么？
     如今从文本文件中读取文本行的最佳方式是不要刻意去读取：其替代方法是，在迭代环境中打开文件，诸如for循环或列表解析中，然后，让迭代工具在每次迭代中执行该文件的next方法，自动一次扫描一行。从代码编写的简易性，执行速度以及内存空间需求等方面来看，这种做法通常都是最佳方式。
