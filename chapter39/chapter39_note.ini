P1046 从某种意义上讲，元类只是扩展了装饰器的代码插入模式。正如我们在上一章所学到的，函数和类装饰器允许我们拦截并扩展函数调用以及类实例创建调用。以类似的思路，元类允许我们拦截并扩展类创建——它们提供了一个API以插入在一条class语句结束时运行的额外逻辑，尽管是以与装饰器不同的方式。同样，它们提供了一种通用的协议来管理程序中的类对象。
P1047 内省属性:像__class__和__dict__这样的特殊属性允许我们查看Python对象的内部实现方面，以便更广泛地处理它们，列出对象的所有属性、显示一个类名，等等。
      运算符重载方法:像__str__和__add__这样特殊命名的方法，在类中编写来拦截并提供应用于类实例的内置操作的行为，例如，打印、表达式运算符等等。它们自动运行作为对内置操作的响应，并且允许类符合期望的接口。
      属性拦截方法:一类特殊的运算符重载方法提供了一种方法在实例上广泛地拦截属性访问：__getattr__、__setattr__和__getattribute__允许包装的类插入自动运行的代码，这些代码可以验证属性请求并且将它们委托给嵌入的对象。它们允许一个对象的任意数目的属性——要么是选取的属性，要么是所有的属性——在访问的时候计算。
      类特性:内置函数property允许我们把代码和特殊的类属性关联起来，当获取、赋值或删除该属性的时候就自动运行代码。尽管不像前面一段所介绍的工具那样通用，特性考虑到了访问特定属性时候的自动代码调用。
      类属性描述符:其实，特性只是定义根据访问自动运行函数的属性描述符的一种简洁方式。描述符允许我们在单独的类中编写__get__、__set__和__delete__处理程序方法，当分配给该类的一个实例的属性被访问的时候自动运行它们。它们提供了一种通用的方式，来插入当访问一个特定的属性时自动运行的代码，并且在一个属性的常规查找之后触发它们。
      函数和类装饰器:正如我们在第38章看到的，装饰器的特殊的@可调用语法，允许我们添加当调用一个函数或创建一个类实例的时候自动运行的逻辑。这个包装器逻辑可以跟踪或计时调用，验证参数，管理类的所有实例，用诸如属性获取验证的额外行为来扩展实例，等等。装饰器语法插入名称重新绑定逻辑，在函数或类定义语句的末尾自动运行该逻辑——装饰的函数和类名重新绑定到拦截了随后调用的可调
      元类是这些技术的延续——它们允许我们在一条class语句的末尾，插入当创建一个类对象的时候自动运行的逻辑。这个逻辑不会把类名重新绑定到一个装饰器可调用对象，而是把类自身的创建指向特定的逻辑。
      换句话说，元类最终只是定义自动运行代码的另外一种方式。通过元类以及前面列出的其他工具，Python为我们提供了在各种环境中插入逻辑的方法——在运算符计算时、属性访问时、函数调用时、类实例创建时，现在是在类对象创建时。
P1051 元类所做的事情——通过声明一个元类，我们告诉Python把类对象的创建路由到我们所提供的另一个类：
    def extra(self, arg): ...
    class Extras(type):
        def __init__(Class, classname, superclasses, attributedict):
            if required():
                Class.extra = extra
    class Client1(metaclass=Extras): ... # Metaclass declaration only
    class Client2(metaclass=Extras): ... # Client class is instance of meta
    class Client3(metaclass=Extras): ...
    X = Client1() # X is instance of Client1
    X.extra()
P1053 在Python 3.0中，用户定义的类对象是名为type的对象的实例，type本身是一个类。
      >>> type([]) # In 3.0 list is instance of list type
      <class 'list'>
      >>> type(type([])) # Type of list is type class
      <class 'type'>
      >>> type(list) # Same, but with type names
      <class 'type'>
      >>> type(type) # Type of type is type: top of hierarchy
      <class 'type'>
P1054 类是类型，类型也是类。即：
      类型由派生自type的类定义。
      用户定义的类是类型类的实例。
      用户定义的类是产生它们自己的实例的类型。
P1054 Python 3.0中的类（以及Python 2.6中的新式类）是type类的实例，并且实例对象是它们的类的实例。实际上，类现在有了连接到type的一个__class__，就像是一个实例有了链接到创建它的类的__class__：
      >>> class C: pass # 3.0 class object (new-style)
      ...
      >>> X = C() # Class instance object
      >>> type(X) # Instance is instance of class
      <class '__main__.C'>
      >>> X.__class__ # Instance's class
      <class '__main__.C'>
      >>> type(C) # Class is instance of type
      <class 'type'>
      >>> C.__class__ # Class's class is type
      <class 'type'>
      特别注意这里的最后两行——类是type类的实例，就像常规的实例是一个类的实例一样。在Python 3.0中，这对于内置类和用户定义的类类型都是成立的。实际上，类根本不是一个独立的概念：它们就是用户定义的类型，并且type自身也是由一个类定义的。
P1055 由于类实际上是type类的实例，从type的定制的子类创建类允许我们实现各种定制的类。在Python 3.0中以及在Python 2.6的新式类中：
      type是产生用户定义的类的一个类。
      元类是type类的一个子类。
      类对象是type类的一个实例，或一个子类。
      实例对象产生字一个类。
      换句话说，为了控制创建类以及扩展其行为的方式，我们所需要做的只是指定一个用户定义的类创建自一个用户定义的元类，而不是常规的type类。
P1057 在Python 3.0中，在类标题中把想要的元类作为一个关键字参数列出来：
      class Spam(metaclass=Meta): # 3.0 and later
      继承超类也可以列在标题中，在元类之前。例如，在下面的代码中，新的类Spam继承自Eggs，但也是Meta的一个实例并且由Meta创建：
      class Spam(Eggs, metaclass=Meta): # Other supers okay
P1063 由于元类以类似于继承超类的方式来制定，因此它们乍看上去有点容易令人混淆。一些关键点有助于概括和澄清这一模型：
      元类继承自type类。尽管它们有一种特殊的角色元类，但元类是用class语句编写的，并且遵从Python中有用的OOP模型。例如，就像type的子类一样，它们可以重新定义type对象的方法，需要的时候重载或定制它们。元类通常重新定义type类的__new__和__init__，以定制类创建和初始化，但是，如果它们希望直接捕获类末尾的创建调用的话，它们也可以重新定义__call__。
      元类声明由子类继承。在用户定义的类中，metaclass=M声明由该类的子类继承，因此，对于在超类链中继承了这一声明的每个类的构建，该元类都将运行。
      元类属性没有由类实例继承。元类声明指定了一个实例关系，它和继承不同。由于类是元类的实例，所以元类中定义的行为应用于类，而不是类随后的实例。实例从它们的类和超类获取行为，但是，不是从任何元类获取行为。从技术上讲，实例属性查找通常只是搜索实例及其所有类的__dict__字典；元类不包含在实例查找中。
P1078 什么是元类？
      元类是用来创建一个类的类。常规的类默认的是type类的实例。元类通常是type类的子类，它重新定义了类创建协议方法，以便定制在一条class语句的末尾发布的类创建调用；它通常会重定义__new__和__init__方法以接入类创建协议。元类也可以以其他的方式编码——例如，作为简单函数——但是它们负责为新类创建和返回一个对象。
P1078 在管理类方面，类装饰器如何与元类重叠？
      由于二者都是在一条class语句的末尾自动触发，因此类装饰器和元类都可以用来管理类。装饰器把一个类名重新绑定到一个可调用对象的结果，而元类把类创建指向一个可调用对象，但它们都是可以用作相同目的的钩子。要管理类，装饰器直接扩展并返回最初的类对象。元类在创建一个类之后扩展它。
P1078 在管理实例方面，类装饰器如何与元类重叠？
      由于二者都是在一条class语句的末尾自动触发，因此类装饰器和元类都可以用来管理类实例，通过插入一个包装器对象来捕获实例创建调用。装饰器把类名重新绑定到一个可调用对象，而该可调用对象在实例创建时运行以保持最初的类对象。元类可以做同样的事情，但是，它们必须也创建类对象，因此，它们用在这一角色中更复杂一些。
