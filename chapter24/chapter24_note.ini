P593 把下划线放在变量名前面（例如，_X），可以防止客户from *语句导入模块名时，把其中的那些变量名复制出去。但是可以使用import语句看见并修改这些变量。
P594 每个模块都有个名为__name__的内置属性，python会自动设置该属性：
     如果文件是以顶层程序文件执行，在启动时，__name__就会设置为字符串"__main__"。
     如果文件被导入，__name__就会改设成客户端所了解的模块名。
     以__name__进行单元测试，
     if __name__ == '__main__':
P599 sys.path=[r'd:\\temp']
     sys.path.append('c:\\lp4e\examples')
P599 import modulename as name 
     相当于：
     import modulename
     name=modulename
     del modulename
     from语句也可以这么用，把从某个文件导入的变量名，赋值给脚本中的不同的变量名：from modulename import attrname as name
P600 因为模块通过内置属性显示了它们的大多数有趣的特性，因此，可很容易的写出程序来管理其他程序。我们通常称这类管理程序为元程序，因为它们是在其他系统之上工作。这也称为内省，因为程序能看见和处理对象的内部。内省是高级功能，但是，它可以用来创建程序的工具。
     例如，要取得M模块内名为name的属性，可以使用结合点号运算，或者对模块的属性字典进行索引（在内置__dict__属性中显示）。python也在sys.module字典中导出所有已加载模块的列表（也就是sys模块的modules属性），并提供一个内置函数getattr，让我们以字符串名来取出属性。因此，下列所有表达式都会得到相同的属性和对象。
     M.name
     M.__dict__['name']
     sys.modules['M'].name
     getattr(M,'name')
P609 from复制变量名，而不是连接：
     from语句其实是在导入者的作用域内对变量名的赋值语句，也就是变量名拷贝运算，而不是变量名的别名机制。
P610 from*会让变量语义含糊：
     使用from module import *语句形式时，你不会列出想要的变量，可能会意外覆盖了作用域内已使用的变量名。更糟的是，这将难以确认变量来自何处。如果有一个以上的被导入文件使用了from*形式，就更是如此了。
P613 模块顶层以下划线开头的变量名的重要性是什么？
     模块顶层变量名已单个下划线开头时，当使用from*语句形式导入，这些变量名不会被复制到进行导入的作用域中。不过，这些变量名还是可通过import或者普通的from语句形式来导入。
P613 改变sys.path和设置PYTHONPATH来修改模块搜索路径有什么不同？
     修改sys.path只会影响一个正在运行的程序，是暂时的，当程序结束时，修改就会消失。PYTHONPATH设置是存在于操作系统中的，机器所有程序都会使用，而且对这些设置的修改在程序离开后还会保存。
