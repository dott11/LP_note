P415 在代码中变量名被赋值的位置决定了这个变量名能被访问到的范围，也是它的可见范围。

P415 一个函数的所有变量名都是与函数的命名空间相关联的：
     1.一个在def内定义的变量名能够被def内的代码使用。不能在函数的外部引用这样的变量名。
     2.def之中的变量名与def之外的变量名并不冲突，即使是使用在别处的相同的变量名。

P416 变量可以在3个不同的地方分配，分别对应3种不同的作用域：
     1.如果一个变量在def内赋值，它被定位在这个函数之内。
     2.如果一个变量在一个嵌套的def中赋值，对于嵌套的函数来说，它是非本地的。
     3.如果在def之外赋值，它就是整个文件全局的。

P416 作用域法则：
     1.内嵌的模块是全局作用域。
     2.全局作用域的作用范围仅限于单个文件。（这里的全局指的是在一个文件的顶层的变量名仅对于这个文件内部的代码而言是全局的）
     3.每次对函数的调用都创建了一个新的本地作用域。
     4.赋值的变量名除非声明为全局变量或非全局变量，否则均为本地变量。
     5.所有其他的变量名都可以归纳为本地、全局或者内置的。在函数定义内部的尚未赋值的变量名是一个在一定范围内（在这个def内部）的本地变量、全局（在一个模块的命名空间内部）或者内置（还有python的预定义__builtin__模块提供的）变量。

P418 变量名解析：LEGB原则
     当在函数中使用未认证的变量名时，Python搜索4个作用域[本地作用域（L），之后是上一层结构中def或lambda的本地作用域（E），之后是全局作用域（G），最后是内置作用域（B）]并且在第一处能够找到这个变量名的地方停下来，如果变量名在这次搜索中没有找到，Python会报错。

P420 内置作用域：内置作用域仅仅是一个名为__builtin__的内置模块，但是必须import__builtin__之后才能使用内置作用域，因为变量名builtin本身并没有预先内置。

P431 作用域与带有循环变量的默认参数相比较：
     如果lambda或者def在函数中定义，嵌套在一个循环之中，并且嵌套的函数引用了一个上层作用域的变量，该变量被循环改变，所有在这个循环中产生的函数将会有相同的值——在最后一次循环中完成时被引用变量的值。
     >>>def makeActions():
     ...    acts[]
     ...    for i in range(5):
     ...        acts.append(lambda x:i**x)
     ...    return acts
     >>>acts=makeACtions()
     >>>acts[0](2)
     16
     >>>acts[2](2)
     16
     >>>acts[4](2)
     16
     因为嵌套作用域中的变量在嵌套的函数被调用时才进行查找，所以它们实际上记住的是同样的值（在最后一次循环迭代中循环变量的值）。
     >>>def makeActions():
     ...    acts[]
     ...    for i in range(5):
     ...        acts.append(lambda x,i=i:i**x)
     ...    return acts
     >>>acts=makeACtions()
     >>>acts[0](2)
     0
     >>>acts[2](2)
     4
     >>>acts[4](2)
     16

P433 nonlocal语句：nonlocal和global一样，声明了将要在一个嵌套的作用域中修改的名称。和global不同之处在于，nonlocal应用于一个嵌套的函数的作用域中的一个名称，而不是所有def之外的全局模块作用域；而且在声明nonlocal名称的时候，它必须已经存在于该嵌套函数的作用域中——它们可能只存在于一个嵌套的函数中，并且不能由一个嵌套的def中的第一次赋值创建。

P437 nonlocal保存状态，与全局共享状态，使用类的状态，使用函数属性的状态。
