P979 装饰是为函数和类指定管理代码的一种方式。装饰器本身的形式是处理其他的可调用对象的可调用的对象（如函数）。Python装饰器以两种相关的形式呈现：
     函数装饰器在函数定义的时候进行名称重绑定，提供一个逻辑层来管理函数和方法或随后对它们的调用。
     类装饰器在类定义的时候进行名称重绑定，提供一个逻辑层来管理类，或管理随后调用它们所创建的实例。
     简而言之，装饰器提供了一种方法，在函数和类定义语句的末尾插入自动运行代码——对于函数装饰器，在def的末尾；对于类装饰器，在class的末尾。
P980 管理调用和实例：
     函数装饰器安装包装器对象，以在需要的时候拦截随后的函数调用并处理它们。
     类装饰器安装包装器对象，以在需要的时候拦截随后的实例创建调用并处理它们。
P980 管理函数和类：
     函数装饰器也可以用来管理函数对象，而不是随后对它们的调用——例如，把一个函数注册到一个API。然而，我们在这里主要关注更为常见的用法，即调用包装器应用程序。
     类装饰器也可以用来直接管理类对象，而不是实例创建调用——例如，用新的方法扩展类。这些用法和元类有很大的重合。
P982 在编码方面，函数装饰器自动将如下的语法：
        @decorator # Decorate function
        def F(arg):
           ...
        F(99) # Call function
     映射为这一对等的形式，其中装饰器是一个单参数的可调用对象，它返回与F具有相同数目的参数的一个可调用对象：
        def F(arg):
            ...
        F = decorator(F) # Rebind function name to decorator result
        F(99) # Essentially calls decorator(F)(99)
P986 从语法上讲，类装饰器就像前面的class语句一样（就像前面函数定义中出现的函数装饰器）。在语法上，假设装饰器是返回一个可调用对象的一个单参数的函数，类装饰器语法：
        @decorator # Decorate class
        class C:
            ...
        x = C(99) # Make an instance
     等同于下面的语法——类自动地传递给装饰器函数，并且装饰器的结果返回来分配给类名：
        class C:
            ...
        C = decorator(C) # Rebind class name to decorator result
        x = C(99) # Essentially calls decorator(C)(99)
P988 为了支持多步骤的扩展，装饰器语法允许我们向一个装饰的函数或方法添加包装器逻辑的多个层。当使用这一功能的时候，每个装饰器必须出现在自己的一行中。这种形式的装饰器语法：
     @A
     @B
     @C
     def f(...):
     ...
     如下这样运行：
     def f(...):
     ...
     f = A(B(C(f)))
P1008 单例模式：
     class singleton:
        def __init__(self, aClass): # On @ decoration
            self.aClass = aClass
            self.instance = None
        def __call__(self, *args): # On instance creation
            if self.instance == None:
                self.instance = self.aClass(*args) # One instance per class
            return self.instance
P1015 从负面的角度讲，类装饰器有两个潜在的缺陷：
      类型修改:正如我们所见到的，当插入包装器的时候，一个装饰器函数或类不会保持其最初的类型——其名称重新绑定到一个包装器对象，在使用对象名称或测试对象类型的程序中，这可能会很重要。在单体的例子中，装饰器和管理函数的方法都为实例保持了最初的类类型；在跟踪器的代码中，没有一种方法这么做，因为需要有包装器。
      额外调用:通过装饰添加一个包装层，在每次调用装饰对象的时候，会引发一次额外调用所需的额外性能成本——调用是相对耗费时间的操作，因此，装饰包装器可能会使程序变慢。在跟踪器代码中，两种方法都需要每个属性通过一个包装器层来指向；单体的示例通过保持最初的类类型而避免了额外调用。
P1015 装饰器有3个主要优点。装饰器提供：
      明确的语法:装饰器使得扩展明确而显然。它们的@比可能在源文件中任何地方出现的特殊代码要容易识别，例如，在单体和跟踪器实例中，装饰器行似乎比额外代码更容易被注意到。此外，装饰器允许函数和实例创建调用使用所有Python程序员所熟悉的常规语法。
      代码可维护性:装饰器避免了在每个函数或类调用中重复扩展的代码。由于它们只出现一次，在类或者函数自身的定义中，它们排除了冗余性并简化了未来的代码维护。对于我们的单体和跟踪器示例，要使用管理器函数的方法，我们需要在每次调用的时候使用特殊的代码——最初以及未来必须做出的任何修改都需要额外的工作。
      一致性:装饰器使得程序员忘记使用必需的包装逻辑的可能性大大减少。这主要得益于两个优点——由于装饰是显式的并且只出现一次，出现在装饰的对象自身中，与必须包含在每次调用中的特殊代码相比较，装饰器促进了更加一致和统一的API使用。如，在单体示例中，可能更容易忘了通过特殊代码来执行所有类创建调用，而这将会破坏单体的一致性管理。
      装饰器还促进了代码的封装以减少冗余性，并使得未来的维护代价最小化。尽管其他的编码结构化工具也能做到这些，但装饰器使得这对于扩展任务来说更自然。然而，这三个优点还不是使用装饰器语法的必需的原因，装饰器的用法最终还是一个格式选择。也就是说，大多数程序员发现了一个纯粹的好处，特别是它作为正确使用库和API的一个工具。
P1016 本章中，我们的大多数示例都设计来拦截函数和实例创建调用。尽管这对于装饰器来说很典型，它们并不限于这一角色。因为装饰器通过装饰器代码来运行新的函数和类，从而有效地工作，它们也可以用来管理函数和类对象自身，而不只是管理对它们随后的调用。
      例如，假设你需要被另一个应用程序使用的方法或类注册到一个API，以便随后处理（可能该API随后将会调用该对象，以响应事件）。尽管你可能提供一个注册函数，在对象定义之后手动地调用该函数，但装饰器使得你的意图更为明显。
